
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5


= RISC-V Overlay “Software Standard Proposal” Version 0.1-draft-20201018



**Revision History**
[cols=",,,",options="header",]
|=============================================
|*_Revision_* |*_Date_* |*_Contents_* |*_Author(s)_*
|0.1 |Oct 07,2020 |Initial revision / Draft a
|Ronen Haen
 +
 Ofer Shinaar
 +
 Craig Blackmore

| | | |
|=============================================
{nbsp} +
{nbsp} +


**List of Figures**


{nbsp} +
{nbsp} +

**List of Tables**

link:#instrumentation-interface-hooks[Table 1 - Instrumentation interface hooks]

{nbsp} +
{nbsp} +

**Reference Documents**
[cols=",,,",options="",]
|========================================
|Item # |Document |Revision Used |Comment
|1 | | |
|========================================

{nbsp} +
{nbsp} +

[[_Toc507430300]]**Abbreviations**

[cols=",",options="",]
|===========================
|Abbreviation |Description
|SW           |Software
|HW           |Hardware
|MMU          |Memory Management Unit
|LRU          |Least Recently Used
|OS           |Operation System
|RT           |Runtime
|RT-Engine    |Runtime Engine
|RTOS         |Real-Time Operating System
|R/O or RO    |Read Only
|===========================

{nbsp} +
{nbsp} +

[[overview]]
== Overview

Physical memory is one of the most important resources in SW programming, since the program runs on it. Some embedded systems have limited memory resources and as a result the total code footprint is often bigger than the available memory. To solve this problem, the program needs to use a technique to load executable code at runtime from virtual memory or to overwrite executable code that is not currently needed by the program.

On OS driven systems a virtual memory is very commonly used, the OS will use a HW MMU with direct mapping between virtual and the physical memory.

There is another technique that can be used to realize this paradigm in SW without the need for special HW. It is called ‘SW overlay”.

The concept of arranging code in ‘code overlays’ is quite old but still valid these days to resolve the code size issue. For small embedded systems (like IoT) footprint and code size is critical. Those systems usually will not be driven by a large OS (e.g. Unix) and will not include a MMU.

An overlay represents a function or read-only data that by some scheme will be loaded into heap area when the SW requires it (e.g. for a function call). The overlay solution offers an advantage over HW, since the SW controls what needs to be loaded and when.

{nbsp} +
{nbsp} +

[[goals]]
== Goals

This document specifies the requirements for all the relevant SW entities needed to implement SW overlays. We expect changes in the toolchain and a requirement for a RT-Engine that handles calls/returns involving overlay functions and loads overlay functions/data as needed. The following requirements will lay a base for everyone to implement their own RT-Engine or toolchain support and/or take just part of the tools and integrate it with their own design.

The main goal of this standard is to make the SW developer experience an easy and smooth one. From the developer's point-of-view the request will be to just tag their designated overlay functions and overlay data with an attribute and the toolchain and RT-Engine will take care of the rest.

The implementation will be based on the RISC-V ISA and RISC-V tools but can be adopted to other targets.

{nbsp} +
{nbsp} +

[[methods-requirements]]
== Methods requirements

The following sections specify the requirements for:

1.  RT-Engine – SW module which is responsible for managing the overlay heap. This module is designated to be part of operational SW.
2.  Toolchain – broad collection of programming tools (e.g. compiler, linker, debugger, etc.) needed to develop SW applications.

[[run-time-engine]]
=== RT-Engine

[[general]]
==== General

1.  Since SW can be more flexible then HW, we should not use a direct mapping approach for overlays. For a small allocated overlay heap we can map any amount of code.
2.  Functions and read-only data can be in overlays.
3.  Functions and read-only data will be assigned to one or more overlay `groups`.
4.  The RT-Engine will be aware of the functions in the group and how to address them.
5.  The RT-Engine will manage the loading/eviction of groups via hooks to be implemented by the platform.
6.  The RT-Engine can run on a bare metal system or under a RTOS and therefore should be aware of RTOS usage to ensure it is thread-safe, since any given thread can invoke overlay functions or use overlay data.

{nbsp} +
[[groups]]
==== Groups

A ‘Group’ is a collection of overlay functions and overlay data. We should use groups to minimize the necessity of loading/evicting a singular function from the overlay heap.

1.  Overlay group size can impact the RT-Engine and the toolchain so it must be selected pre-build.
2.  Overlay group size ranges from 512B – 4K for both functions and RO data.
3.  Group size will be decided in advance by the developer, and we will be provided at link-time.
4.  An overlay function or overlay data must not be bigger than the maximum group size.
5.  _Multi Group_ – an overlay function or overlay data can be resident in N groups. +
Example: foo(void) can be located in _Group~1~, Group~2~…, GroupN_

{nbsp} +
[[evict]]
==== Evict

Group eviction can be handled with similarity to HW cache concepts.

1.  Eviction resolution will be at `group` granularity, meaning we can evict N groups per demand.
2.  The search-algorithm for determining whether a group is loaded or not shall be defined at compile time.
3.  The RT-Engine will provide a “group lock/free” API mechanism to prevent specific groups from being evicted.

{nbsp} +
[[load]]
==== Load

The load area, “heap”, contains loaded overlay groups. It should have its own memory section definition, so that the RT-Engine and the toolchain can work on the same section.

1.  The heap area should be defined pre-build.
2.  The heap should have range limitation to be in sync with the RT-Engine and toolchain. The heap minimum size should not be smaller than the maximum pre-defined overlay group size.
3.  We can have multiple heaps to be controlled by a single/multiple RT-Engine(s).
4.  A _Load-Function-Hook_ footnote:[Hook implementation will be the responsibility of the platform since only the platform knows how to implement them. +
Please refer to section *_3.1.6 Platform/Framework Hooks_*] will be provided to the user for executing the load operation itself.

{nbsp} +
[[invoke]]
==== Invoke

The RT-Engine will be the entity to invoke the overlay function.

1.  The RT-Engine should support invoking indirect function calls (i.e. calls via function-pointers)
2.  The search-algorithm is open to interpretation; we recommend to have at least one, for example LRU.
3.  After a function is loaded to the heap, the RT-Engine will be responsible for passing all requested arguments from the root caller to the callee.
+
Therefore, the RT-Engine will apply the ABI rules.
4.  Following the RISCV psABI, we should support #8 argument registers.

{nbsp} +
[[platformframework-hooks]]
==== Platform/Framework Hooks

Hooks implementation will be the responsibility of the platform since only the platform knows how to implement them. +
RT-Engine design may be dependent on platform resources (e.g. “enter critical” section) or may be able to leverage platform features to increase performance of the engine. +
For those the engine will need to expose API hooks to be provided by the platform/framework.

There are several types of hooks that need to be standardized so they can be used in any implementation:

[[load-function-hook]]
===== Load Function Hook

A hook triggered by the RT-Engine to request the load of a group.

The API will need to provide information which is understood by the engine and the user, +
AKA Overlay Static table (_link:#linker[Linker section: Overlay Static Table]_)

Example:

* Source: group location/referenced from the _‘Overlay Static Table’_
* Size of group
* Destination to load

[[error-hook]]
===== Error-Hook

On encountering an error, the RT-Engine will call the Error-Hook.

[[instrumentation-interface-hooks]]
===== Instrumentation interface hooks

Instrumentation is needed for analysis, which can be used to improve the performance of overlay function calls.
For example: user can catch a sequence of overlay-function-calls, from the instrumentation, and according to the result he can encapsulate the functions to a specific group.

.Instrumentation interface hooks
[cols="1%,30%,50%",options="header,,autowidth",]
|======================================================================================================================
| |Instrumentation name |Description
|1.|Invoke callee + Load |Load overlay function and invoke it
|2.|Invoke caller (return) + load |When returning to an overlay function, and re-loading of the ‘caller’ is needed
|3.|Invoke callee + No load |The callee function is already loaded, we just need to invoke it
|4.|Invoke caller (return) + No load |When returning from an overlay function and re-loading of the ‘caller’ is needed
|======================================================================================================================


[[rtos-hooks]]
===== RTOS hooks

On RTOS based system, the RT-Engine will provide hooks to protect its critical sections. Those hooks will be implemented by the user.

{nbsp} +

[[rtos]]
==== RTOS

The RT-Engine should support a system bare metal design and/or RTOS system design.

1.  The implementation with/without RTOS should be a compile-time option.
2.  If RTOS is supported, the RT-Engine should be thread-safe and not block other threads due to overlay operations.
3.  Blocking can be acceptable for short critical sections and only with inherent operations (e.g. mutex).
4.  The RT-Engine should be agnostic to any specific RTOS, therefore hooks should be provided _(link:#rtos-hooks[RTOS hooks])_.
5.  Load operations should lock the designated memory region in the heap, to prevent a case where a higher priority task will take the region from the current running task.

{nbsp} +
{nbsp} +

[[toolchain]]
=== Toolchain

The toolchain needs to be integrated with the overlay standard to support the usage of overlays.
The compiler, linker and debugger all need to support the overlay mechanism in order for the user to use overlay functions and data and debug them. The following are the module-requirements per tool.

{nbsp} +

[[compiler]]
==== Compiler

The main compiler demands are related to generating a sequence code to enter the RT-Engine whenever the running code references an overlay symbol, which can be data usage or function call/return.

1.  The compiler needs to generate code for any related overlay usage, the sequence will lead to entering to the RT-Engine which then manages the process of loading, evicting, etc…
2.  The user will need to add a designated attribute to its target overlay function or data to make the compiler emit the designated sequence for example: "\___attribute___ (overlaycall)" or "\___attribute___ (overlaydata)"
3.  Types of related overlay use cases:
a.  Direct call – just calling to the overlay function
b.  Indirect call – call is via function pointer
c.  Data – data which is marked as overlay should be referenced with the same sequence to enter the RT-Engine so that the data can be loaded as necessary.
4.  We probably need to reserve a few core registers to be used only for the RT-Engine. Those registers will have a special purpose understood by the compiler, linker, debugger and RT-Engine. Moreover those registers form a _RT-Eng-Debugger-handshake_ between compiler, RT code and debugger.
+
Any library linked with an overlay enabled program must be built without using the reserved registers.
5.  The compiler should pass a descriptor/token to the RT-Engine via an 'entry' sequence. +
The descriptor will be materialized at link time.
6.  Related debug information should be aligned with the compiler overlay scheme.

{nbsp} +

[[linker]]
==== Linker

1.  Overlay symbols cannot be referenced by a memory address, since they are not part of the physical memory. Therefore we should have a descriptor/token to describe the overlay symbol (e.g. specifying the group to which it belongs and its offset within the group).
2.  The linker will get all the necessary data for overlay symbols from: object files, the linker script and linker flags.
3.  The linker shall create an overlay section for each overlay symbol that appears in an object file (as a result of attributes added by the user in the source code).
4.  Each overlay symbol is assigned to one or more *Groups* at link time, as the linker has full visibility of all overlay symbols.
5.  The linker shall have the ability to encapsulate functions and read-only data into overlay groups.
6.  There should be an *_"overlay area"_* that holds all of the groups in the program. This area is not for execution, it is the area from which the RT-Engine will load overlay groups and it is also for the linker to treat overlay functions as regular functions (for address allocation, optimization etc…) and debugging information is associated with the contents of this area.
7.  Multi-group
+
The linker should deal with overlay symbols which can be resident in more then one group:

a. An overlay function can be resident in more than one group.
b. Overlay data can be resident in more than one group.

8.  Overlay Static Table
a.  The linker shall create a group-offset-table to hold all the overlay group offsets. Each entry index in the table represents an overlay group ID. Each entry contents represent the zero base offset to the group.
b.  Overlay group IDs are numerical.
c.  This table can be read at runtime (e.g. by the RT-Engine, debugger or another utility) to provide a mapping to locate an overlay group.
d.  This table shall provide sufficient information for the RT-Engine, debugger or other utilities to find the requested group within the *_"overlay area"_* (for example, so that the FW can find the locate and load a group).
9.  Overlay group size ranges from 512B – 4K for both functions and data.


NOTE: This table is targeted to be a spec between the running code and the low level driver for loading the overlay function (per group). Since the table is part of the code, the developer can manage it and allocate a placeholder for the overlay groups/functions in the storage for example (storage refers to any SW I/F that can fetch the code).

{nbsp} +

[[debugger]]
==== Debugger

Since our goal is to provide a comfortable experience for the SW developer we need support for key debugging features (such as breakpoints and backtracing) on an overlay system where overlay functions and data may be mapped or unmapped (loaded/unloaded).

.  The debugger should give the overlay functions the same debugging capabilities as a non-overlay function (e.g. step, step instruction, skip, backtracing etc…)
.  _RT-Eng-Debugger-handshake:_ The debugger and the RT-Engine will communicate during run-time.
The information passed from the RT-Engine to the debugger will contain the status of the loaded/unloaded (mapped/unmapped) overlay groups.
.  Overlay RT-Engine awareness:
..  For backtracing, the debugger should be able to unwind the stack with awareness of calls/returns through the RT-Engine.
..  To give a comfortable debugging experience we should have an option to “skip” through the RT-Engine when doing a step on a function call or return. E.g. if we step at call to function myOverlayFoo(), the debugger should skip through the RT-Engine and the next PC we see will be the beginning of myOverlayFoo() and not within the RT-Engine. Similarly, if we step at a function return, the debugger should skip through the RT-Engine and the next PC we see will be at the return address in the caller.
..  There should also be an option to disable this “skip” functionality to allow debugging of the RT-Engine.

.  The debugger will be agnostic to the existence of a RTOS, this means a context switch can happen during an overlay operation and the debugger should hold a valid sequence.
.  Changes in the debugger should be generic in such a way that all related _“RT-Eng-Debugger-handshake”_  will be in an external file to hook into the debugger.
. We shall have debug information for overlay functions, that information should be symmetric if a function is placed in several groups (*_multi group_*).
